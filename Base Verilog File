//This is definitions for our instruction types
`define add   4'b0000
'define sub   4'b0001
'define sll   4'b0010
'define srl   4'b0011
'define ori   4'b0100
'define slt   4'b0101
'define lw    4'b0110
'define sw    4'b0111
'define beq   4'b1000
'define bne   4'b1001
'define j     4'b1010
'define and   4'b1100
'define or    4'b1101
'define xor   4'b1110
'define addi  4'b1111

// This is a function for slti to distinguish from slt
'define slti  3'101

// input line     
input [15:0] din;


reg [3:0] control;
reg [2:0] function;
reg [2:0] rs;
reg [2:0] rt;
reg [2:0] rd;
reg [3:0] result;

//these are signals to send to the ALU after the opcodes come in
reg [0] add;
reg [0] sub;
reg [0] and;
reg [0] or;

//assignment of current instruction values
control = din[15:11]
rs = din[10:8]
rt = din[7:5]
rd = din[5:3]
function = din[2:0]


//control block - sets control signals
always @* begin

 case(control)
 
  `add: begin 
   add = 1;
end

//ALU Block - controls ALU functionality
always @(posedge clk or posedge reset) begin
 result = 0;
 if(add == 1)
   result = rs + rt;
 if(sub == 1)
   result = rs - rt;
 if(and == 1)
   result = rs & rt;
 if(or == 1)
   result = rs | rt;
 if(rs[2] == 0 | rt[2] == 0 | result[2] == 1)
   //overflow have to put case for this
 if(rs[2] == 1 | rt[2] == 1 | result[2] == 0)
   //overflow again
 rd = result[2:0];
end
